<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spiral Staircase Around Old Tree - Three.js</title>
  <style>
    body { margin: 0; overflow: hidden; touch-action: none; }
    canvas { display: block; }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #overlay img {
      max-width: 80%;
      max-height: 80%;
    }
  </style>
</head>
<body>
  <!-- Include Three.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // Set up the scene, camera, and renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Set background color to light blue (for a blue sky effect)
    scene.background = new THREE.Color(0x87CEEB); // Light blue color for the sky

    // Add sunlight (Directional light to simulate the Sun)
    const sunlight = new THREE.DirectionalLight(0xFFFF00, 1.0); // Slight yellowish color for sunlight
    sunlight.position.set(50, 50, 50); // Place the sun far away from the scene
    sunlight.castShadow = true; // Enable shadows from the sunlight
    sunlight.shadow.bias = -0.005; // Adjust bias to avoid shadow acne
    sunlight.shadow.mapSize.width = 2048;  // Set high resolution shadow map
    sunlight.shadow.mapSize.height = 2048; // Set high resolution shadow map
    scene.add(sunlight);

    // Create the tree and spiral staircase
    const height = 60;  // Increased tree height
    const steps = 100;  // Increase number of steps for a longer staircase

    // Create the tree trunk (old-looking tree)
    const trunkGeometry = new THREE.CylinderGeometry(1, 2, height, 16); // Tall, thick trunk
    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.y = height / 2; // Position the trunk at the base
    trunk.castShadow = true; // Enable the trunk to cast shadows
    scene.add(trunk);

    // Add branches to the tree (old tree with branches)
    const branchGeometry = new THREE.SphereGeometry(0.5, 8, 8);
    const branchMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
    for (let i = 0; i < 8; i++) {
      const branch = new THREE.Mesh(branchGeometry, branchMaterial);
      branch.position.set(Math.random() * 3 - 1.5, height * Math.random(), Math.random() * 3 - 1.5);
      branch.castShadow = true;
      scene.add(branch);
    }

    // Create the spiral staircase around the tree
    const stepGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
    const stepMaterial = new THREE.MeshLambertMaterial({ color: 0xBDB76B });

    const radius = 5;
    const angleIncrement = Math.PI / 10;
    const heightIncrement = height / steps;

    for (let i = 0; i < steps; i++) {
      const angle = i * angleIncrement;
      const x = radius * Math.cos(angle);
      const z = radius * Math.sin(angle);
      const y = heightIncrement * i;

      const step = new THREE.Mesh(stepGeometry, stepMaterial);
      step.position.set(x, y, z);
      step.rotation.y = -angle;
      step.castShadow = true; // Enable each step to cast shadows
      scene.add(step);
    }

    // Create a simple character (pink cube)
    const characterGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
    const characterMaterial = new THREE.MeshLambertMaterial({ color: 0xFFC0CB }); // Pink color
    const character = new THREE.Mesh(characterGeometry, characterMaterial);
    character.castShadow = true; // Enable character to cast shadows
    scene.add(character);

    // Mobile scroll interaction variables
    let touchStartY = 0; // To track initial touch position
    let scrollAmount = 0; // Start at the bottom

    // Handle touch events for mobile scrolling
    window.addEventListener('touchstart', (event) => {
      touchStartY = event.touches[0].clientY;
    });

    window.addEventListener('touchmove', (event) => {
      const touchDeltaY = touchStartY - event.touches[0].clientY;
      scrollAmount += touchDeltaY * 0.01; // Adjust the scroll speed
      scrollAmount = Math.max(0, Math.min(scrollAmount, steps - 1)); // Prevent going out of bounds
      touchStartY = event.touches[0].clientY; // Update the starting touch position
      character.position.y = scrollAmount * height / steps;
    });

    // Function to create a pulsing gradient texture for the portal rings
    function createPulsingGradientTexture() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 256;

      // Create a gradient with green and purple (no yellow)
      const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
      gradient.addColorStop(0, 'green');
      gradient.addColorStop(1, 'purple');
      
      // Apply the gradient
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Create a texture from the canvas
      const texture = new THREE.CanvasTexture(canvas);

      // Animate the texture for the pulsing effect
      let pulseTime = 0;
      const pulseSpeed = 0.01;
      function updatePulse() {
        pulseTime += pulseSpeed;
        const offset = Math.sin(pulseTime) * 0.5 + 0.5; // Pulse effect
        gradient.addColorStop(0, `rgb(${Math.floor(255 * offset)}, 0, ${Math.floor(255 * (1 - offset))})`); // Modify gradient dynamically
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        texture.needsUpdate = true;
      }

      return { texture, updatePulse };
    }

    // Create a textboard in the shape of a ring (portal-like)
    function createTextRing(stepIndex) {
      const angle = stepIndex * angleIncrement;
      const x = radius * Math.cos(angle);
      const z = radius * Math.sin(angle);
      const y = heightIncrement * stepIndex;

      // Create the pulsing gradient texture for the ring
      const { texture, updatePulse } = createPulsingGradientTexture();

      // Create a ring geometry (like a portal frame)
      const geometry = new THREE.RingGeometry(2, 3, 32); // Inner and outer radius for the ring
      const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
      const textRing = new THREE.Mesh(geometry, material);

      // Position text rings along the path (spaced evenly)
      textRing.position.set(x, y, z);
      textRing.rotation.x = Math.PI / 2;  // Make the ring face towards the character
      scene.add(textRing);

      // Make the textboard always face the camera (billboard effect)
      textRing.lookAt(camera.position); // Ensure the ring always faces the camera

      // Update the pulse effect in the animation loop
      function pulseEffect() {
        updatePulse();
      }

      return { textRing, pulseEffect, x, y, z };
    }

    // Create an array to store the rings (portals) along the staircase path
    const rings = [];
    for (let i = 0; i < steps; i++) {
      const ring = createTextRing(i);
      rings.push(ring);
    }

    // Set up lighting to simulate realistic shadow effects
    const ambientLight = new THREE.AmbientLight(0x404040, 1); // Soft light to brighten up shadows
    scene.add(ambientLight);

    // Camera position
    camera.position.z = 30;

    // Handle resizing for mobile
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Move the character along the staircase path based on scroll
      const step = scrollAmount * angleIncrement;
      character.position.set(radius * Math.cos(step), scrollAmount * height / steps, radius * Math.sin(step));

      // Update portal ring pulses
      rings.forEach(ring => ring.pulseEffect());

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
